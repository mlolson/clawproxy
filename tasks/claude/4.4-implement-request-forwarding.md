# Task 4.4: Implement Request Forwarding

**Assignee:** Claude
**Dependencies:** 4.3
**Status:** Open

## Description

Implement forwarding of requests to upstream services with credential injection.

## Acceptance Criteria

- [ ] Match incoming request to service config
- [ ] Build upstream URL with rewritten path
- [ ] Copy request headers (except Host)
- [ ] Substitute PROXY:xxx tokens in Authorization header
- [ ] Set correct auth header using service config
- [ ] Forward request body
- [ ] Use reqwest for HTTP client

## Implementation

```rust
// In proxy_handler or separate function

async fn forward_request(
    config: &Config,
    secrets: &HashMap<String, String>,
    request: Request<Body>,
) -> Result<Response<Body>, ProxyError> {
    let path = request.uri().path();
    let query = request.uri().query();

    // Match service
    let (service_name, service) = router::match_service(path, &config.services)
        .ok_or_else(|| ProxyError::UnknownService(path.to_string()))?;

    tracing::debug!(service = service_name, path = path, "Matched service");

    // Build upstream URL
    let upstream_url = router::build_upstream_url(service, path, query);

    // Get the secret for this service
    let secret = secrets
        .get(&service.secret)
        .ok_or_else(|| ProxyError::InvalidToken(service.secret.clone()))?;

    // Build auth header value
    let auth_value = substitution::format_auth_header(&service.auth_format, secret);

    // Create client and build request
    let client = reqwest::Client::new();
    let mut req_builder = client.request(request.method().clone(), &upstream_url);

    // Copy headers (except Host and original auth)
    for (name, value) in request.headers() {
        if name != "host" && name != service.auth_header.to_lowercase().as_str() {
            req_builder = req_builder.header(name, value);
        }
    }

    // Set the auth header
    req_builder = req_builder.header(&service.auth_header, &auth_value);

    // Forward body
    let body_bytes = axum::body::to_bytes(request.into_body(), usize::MAX).await?;
    req_builder = req_builder.body(body_bytes);

    // Send request
    let response = req_builder.send().await
        .map_err(|e| ProxyError::UpstreamRequest(e.to_string()))?;

    // Convert response
    convert_response(response).await
}
```

## Header Handling

| Header | Action |
|--------|--------|
| Host | Replace with upstream host |
| Authorization | Replace with injected secret |
| x-api-key | Replace if service uses it |
| Content-Type | Pass through |
| Others | Pass through |

## Notes

- Consider connection pooling for performance
- Handle timeouts appropriately
- Log service name but NOT the injected secret
