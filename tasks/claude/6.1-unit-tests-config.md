# Task 6.1: Unit Tests â€” Config

**Assignee:** Claude
**Dependencies:** 2.3
**Status:** Open

## Description

Write unit tests for configuration loading and validation.

## Acceptance Criteria

- [ ] Test valid config parsing
- [ ] Test missing file handling (should use defaults)
- [ ] Test invalid YAML handling
- [ ] Test config validation rules
- [ ] Test secrets_dir path resolution

## Test Cases

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_load_valid_config() {
        let dir = TempDir::new().unwrap();
        let config_path = dir.path().join("config.yaml");

        fs::write(&config_path, r#"
listen:
  host: "0.0.0.0"
  port: 9000
secrets_dir: "/custom/secrets"
services:
  test:
    prefix: "/test"
    upstream: "https://test.api.com"
    secret: "test_key"
    auth_header: "Authorization"
    auth_format: "Bearer {secret}"
"#).unwrap();

        let config = Config::load(Some(&config_path)).unwrap();
        assert_eq!(config.listen.port, 9000);
        assert_eq!(config.services.len(), 1);
    }

    #[test]
    fn test_load_missing_file_uses_defaults() {
        let config = Config::load(Some(Path::new("/nonexistent/config.yaml")));
        // Should either return defaults or error - decide on behavior
    }

    #[test]
    fn test_load_invalid_yaml() {
        let dir = TempDir::new().unwrap();
        let config_path = dir.path().join("config.yaml");
        fs::write(&config_path, "not: valid: yaml: {{").unwrap();

        let result = Config::load(Some(&config_path));
        assert!(result.is_err());
    }

    #[test]
    fn test_default_config() {
        let config = Config::default();
        assert_eq!(config.listen.host, "127.0.0.1");
        assert_eq!(config.listen.port, 8080);
        assert!(config.services.contains_key("openai"));
        assert!(config.services.contains_key("anthropic"));
    }

    #[test]
    fn test_secrets_dir_relative_path() {
        let mut config = Config::default();
        config.secrets_dir = PathBuf::from("secrets");

        let resolved = config.secrets_dir();
        assert!(resolved.is_absolute());
        assert!(resolved.ends_with("clawproxy/secrets"));
    }

    #[test]
    fn test_secrets_dir_absolute_path() {
        let mut config = Config::default();
        config.secrets_dir = PathBuf::from("/custom/secrets");

        let resolved = config.secrets_dir();
        assert_eq!(resolved, PathBuf::from("/custom/secrets"));
    }
}
```

## Notes

- Use `tempfile` crate for test directories
- Test edge cases (empty file, partial config)
- Consider property-based testing for config validation
