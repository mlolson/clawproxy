# Task 6.4: Integration Tests â€” Proxy

**Assignee:** Claude
**Dependencies:** 4.6
**Status:** Open

## Description

Write integration tests for the proxy server using wiremock.

## Acceptance Criteria

- [ ] Test auth header injection
- [ ] Test token substitution in headers
- [ ] Test request forwarding
- [ ] Test response passthrough
- [ ] Test error handling (upstream errors)
- [ ] Test streaming responses

## Test Setup

```rust
use wiremock::{MockServer, Mock, ResponseTemplate};
use wiremock::matchers::{method, path, header};

async fn setup_test_server() -> (MockServer, Config, HashMap<String, String>) {
    let mock_server = MockServer::start().await;

    let mut services = HashMap::new();
    services.insert("test".to_string(), ServiceConfig {
        prefix: "/test".to_string(),
        upstream: mock_server.uri(),
        secret: "test_secret".to_string(),
        auth_header: "Authorization".to_string(),
        auth_format: "Bearer {secret}".to_string(),
    });

    let config = Config {
        listen: ListenConfig {
            host: "127.0.0.1".to_string(),
            port: 0, // Random port
        },
        secrets_dir: PathBuf::from("/tmp/test-secrets"),
        services,
    };

    let mut secrets = HashMap::new();
    secrets.insert("test_secret".to_string(), "sk-real-secret-123".to_string());

    (mock_server, config, secrets)
}
```

## Test Cases

```rust
#[tokio::test]
async fn test_auth_header_injection() {
    let (mock_server, config, secrets) = setup_test_server().await;

    // Expect request with injected auth header
    Mock::given(method("POST"))
        .and(path("/v1/chat"))
        .and(header("Authorization", "Bearer sk-real-secret-123"))
        .respond_with(ResponseTemplate::new(200).set_body_json(json!({"ok": true})))
        .mount(&mock_server)
        .await;

    // Start proxy
    let proxy = start_test_proxy(config, secrets).await;

    // Send request to proxy with placeholder token
    let client = reqwest::Client::new();
    let response = client
        .post(format!("{}/test/v1/chat", proxy.url()))
        .header("Authorization", "Bearer PROXY:test_secret")
        .send()
        .await
        .unwrap();

    assert_eq!(response.status(), 200);
}

#[tokio::test]
async fn test_unknown_service_returns_404() {
    let (_, config, secrets) = setup_test_server().await;
    let proxy = start_test_proxy(config, secrets).await;

    let client = reqwest::Client::new();
    let response = client
        .get(format!("{}/unknown/endpoint", proxy.url()))
        .send()
        .await
        .unwrap();

    assert_eq!(response.status(), 404);
}

#[tokio::test]
async fn test_upstream_error_passthrough() {
    let (mock_server, config, secrets) = setup_test_server().await;

    Mock::given(method("POST"))
        .and(path("/v1/chat"))
        .respond_with(ResponseTemplate::new(429)
            .set_body_json(json!({"error": "rate limited"})))
        .mount(&mock_server)
        .await;

    let proxy = start_test_proxy(config, secrets).await;

    let client = reqwest::Client::new();
    let response = client
        .post(format!("{}/test/v1/chat", proxy.url()))
        .send()
        .await
        .unwrap();

    assert_eq!(response.status(), 429);
}

#[tokio::test]
async fn test_streaming_response() {
    // Test SSE passthrough
    let (mock_server, config, secrets) = setup_test_server().await;

    Mock::given(method("POST"))
        .and(path("/v1/chat"))
        .respond_with(ResponseTemplate::new(200)
            .insert_header("content-type", "text/event-stream")
            .set_body_string("data: {\"chunk\": 1}\n\ndata: {\"chunk\": 2}\n\n"))
        .mount(&mock_server)
        .await;

    // Verify streaming works...
}
```

## Notes

- Use `wiremock` for mocking upstream servers
- Test both success and error paths
- Test request body forwarding
- Consider timeout testing
