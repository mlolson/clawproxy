# Task 6.6: End-to-End Tests

**Assignee:** Claude
**Dependencies:** 6.4, 6.5
**Status:** Open

## Description

Write end-to-end tests that verify the complete system works together.

## Acceptance Criteria

- [ ] Test full flow: proxy + sandbox + API request
- [ ] Verify sandbox blocks secret access
- [ ] Verify API requests succeed through proxy
- [ ] Test on both macOS and Linux
- [ ] Use `assert_cmd` for CLI testing

## Test Flow

```
1. Start proxy server
2. Run sandboxed command that:
   a. Tries to read secrets (should fail)
   b. Makes API request through proxy (should succeed)
3. Verify both behaviors
```

## Test Implementation

```rust
use assert_cmd::Command;
use predicates::prelude::*;
use tempfile::TempDir;

#[test]
fn test_sandbox_blocks_secret_read() {
    let dir = setup_test_environment();

    // Try to read secrets while sandboxed
    let mut cmd = Command::cargo_bin("clawproxy-run").unwrap();
    cmd.arg("cat")
        .arg(dir.path().join("secrets/test_secret"))
        .assert()
        .failure()
        .stderr(predicate::str::contains("Operation not permitted")
            .or(predicate::str::contains("Permission denied")));
}

#[test]
fn test_sandbox_allows_normal_operations() {
    // Verify sandboxed process can do normal things
    let mut cmd = Command::cargo_bin("clawproxy-run").unwrap();
    cmd.arg("echo")
        .arg("hello")
        .assert()
        .success()
        .stdout(predicate::str::contains("hello"));
}

#[tokio::test]
async fn test_full_flow_with_mock_api() {
    // 1. Set up mock API server
    let mock_server = MockServer::start().await;
    Mock::given(method("POST"))
        .and(path("/v1/chat"))
        .and(header("Authorization", "Bearer sk-test-key"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(json!({"response": "Hello!"})))
        .mount(&mock_server)
        .await;

    // 2. Set up clawproxy config pointing to mock
    let test_dir = setup_test_environment_with_config(&mock_server.uri());

    // 3. Start proxy
    let proxy_handle = start_proxy_background(&test_dir);

    // 4. Run sandboxed curl that makes request through proxy
    let mut cmd = Command::cargo_bin("clawproxy-run").unwrap();
    cmd.arg("curl")
        .arg("-X").arg("POST")
        .arg("-H").arg("Authorization: Bearer PROXY:test")
        .arg("http://127.0.0.1:8080/test/v1/chat")
        .assert()
        .success()
        .stdout(predicate::str::contains("Hello!"));

    // 5. Cleanup
    proxy_handle.stop();
}

fn setup_test_environment() -> TempDir {
    let dir = TempDir::new().unwrap();

    // Create config
    let config_dir = dir.path().join(".config/clawproxy");
    fs::create_dir_all(&config_dir).unwrap();

    // Create secrets
    let secrets_dir = config_dir.join("secrets");
    fs::create_dir_all(&secrets_dir).unwrap();
    fs::write(secrets_dir.join("test_secret"), "sk-test-key").unwrap();

    // Write config
    fs::write(config_dir.join("config.yaml"), "...").unwrap();

    dir
}
```

## Platform-Specific Tests

```rust
#[test]
#[cfg(target_os = "macos")]
fn test_macos_sandbox_exec() {
    // macOS-specific sandbox test
}

#[test]
#[cfg(target_os = "linux")]
fn test_linux_landlock() {
    // Linux-specific Landlock test
}
```

## CI Configuration

```yaml
# .github/workflows/test.yml
jobs:
  test:
    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo test --all-features
```

## Notes

- Some tests require actual sandbox capabilities
- May need to skip sandbox tests in CI environments without permissions
- Use feature flags for platform-specific tests
