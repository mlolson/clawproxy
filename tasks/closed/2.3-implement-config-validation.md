# Task 2.3: Implement Config Validation

**Assignee:** Human
**Dependencies:** 2.1, 2.2
**Status:** Open

## Why This Task is Assigned to Human

This task helps you understand the config structure deeply by implementing validation rules. You'll need to think through all the ways a config could be invalid.

## Description

Implement validation for the Config struct to catch configuration errors early.

## Acceptance Criteria

- [ ] Implement `Config::validate(&self) -> Result<()>`
- [ ] Validate listen host is valid (IP or hostname)
- [ ] Validate port is in valid range (1-65535)
- [ ] Validate each service has required fields
- [ ] Validate auth_format contains `{secret}` placeholder
- [ ] Validate no duplicate prefixes
- [ ] Return helpful error messages

## Validation Rules

1. **Listen Config**
   - Host must be valid IP or resolvable hostname
   - Port must be 1-65535 (warn if < 1024, requires root)

2. **Services**
   - Prefix must start with `/`
   - Upstream must be valid URL
   - Secret name must be alphanumeric
   - auth_format must contain `{secret}`
   - No two services can have the same prefix

3. **General**
   - At least one service defined
   - secrets_dir path must be valid

## Starter Code

```rust
impl Config {
    pub fn validate(&self) -> Result<()> {
        // Validate listen config
        self.validate_listen()?;

        // Validate services
        self.validate_services()?;

        Ok(())
    }

    fn validate_listen(&self) -> Result<()> {
        // TODO: Validate host
        // TODO: Validate port range

        if self.listen.port < 1024 {
            tracing::warn!(
                port = self.listen.port,
                "Port < 1024 may require root privileges"
            );
        }

        Ok(())
    }

    fn validate_services(&self) -> Result<()> {
        if self.services.is_empty() {
            return Err(ConfigError::Invalid(
                "At least one service must be defined".to_string()
            ).into());
        }

        let mut prefixes = HashSet::new();
        for (name, service) in &self.services {
            // TODO: Validate prefix starts with /
            // TODO: Validate upstream is valid URL
            // TODO: Validate auth_format contains {secret}
            // TODO: Check for duplicate prefixes
        }

        Ok(())
    }
}
```

## Hints

- Use `url::Url::parse()` to validate upstream URLs
- Use a HashSet to track seen prefixes
- Consider edge cases like empty strings

## Testing Your Implementation

```bash
# Create invalid config and test
cat > /tmp/bad-config.yaml << EOF
listen:
  host: "127.0.0.1"
  port: 99999
services: {}
EOF

cargo run --bin clawproxy -- start --config /tmp/bad-config.yaml
# Should fail with validation error
```
