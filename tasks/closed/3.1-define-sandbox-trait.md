# Task 3.1: Define Sandbox Trait and Types

**Assignee:** Claude
**Dependencies:** 1.3
**Status:** Open

## Description

Define the sandbox abstraction layer that works across macOS and Linux.

## Acceptance Criteria

- [ ] Create `src/sandbox/mod.rs`
- [ ] Define `SandboxConfig` struct
- [ ] Define `Sandbox` trait
- [ ] Add `SandboxError` variants to error.rs
- [ ] Implement `create_sandbox()` factory function with OS detection
- [ ] Create stub files for `macos.rs` and `linux.rs`

## Implementation

```rust
// src/sandbox/mod.rs

#[cfg(target_os = "linux")]
pub mod linux;
#[cfg(target_os = "macos")]
pub mod macos;

use std::collections::HashMap;
use std::path::PathBuf;
use crate::error::Result;

#[derive(Debug, Clone)]
pub struct SandboxConfig {
    /// Paths the sandboxed process cannot read
    pub deny_read: Vec<PathBuf>,
    /// Paths the sandboxed process cannot write
    pub deny_write: Vec<PathBuf>,
    /// Environment variables to set
    pub env: HashMap<String, String>,
}

impl SandboxConfig {
    /// Create config for protecting secrets directory
    pub fn for_secrets(secrets_dir: PathBuf, proxy_url: &str) -> Self {
        let mut env = HashMap::new();
        env.insert("HTTP_PROXY".to_string(), proxy_url.to_string());
        env.insert("HTTPS_PROXY".to_string(), proxy_url.to_string());
        env.insert("http_proxy".to_string(), proxy_url.to_string());
        env.insert("https_proxy".to_string(), proxy_url.to_string());

        Self {
            deny_read: vec![secrets_dir.clone()],
            deny_write: vec![secrets_dir],
            env,
        }
    }
}

pub trait Sandbox {
    /// Apply sandbox and exec into command. Does not return on success.
    fn exec_sandboxed(
        &self,
        config: &SandboxConfig,
        cmd: &str,
        args: &[String],
    ) -> Result<std::convert::Infallible>;
}

pub fn create_sandbox() -> Result<Box<dyn Sandbox>> {
    #[cfg(target_os = "macos")]
    return Ok(Box::new(macos::MacOsSandbox));

    #[cfg(target_os = "linux")]
    return Ok(Box::new(linux::LinuxSandbox));

    #[cfg(not(any(target_os = "macos", target_os = "linux")))]
    return Err(SandboxError::NotAvailable.into());
}
```

## Error Types

Add to `src/error.rs`:

```rust
#[derive(Error, Debug)]
pub enum SandboxError {
    #[error("Sandbox not available on this platform")]
    NotAvailable,

    #[error("Failed to create sandbox profile: {0}")]
    ProfileCreation(String),

    #[error("Failed to apply sandbox: {0}")]
    Apply(String),

    #[error("Failed to execute command: {0}")]
    Exec(String),

    #[error("Landlock not supported (kernel 5.13+ required)")]
    LandlockNotSupported,
}
```

## Notes

- The trait returns `Infallible` because exec replaces the process
- On error, the original process continues so we can return an error
