# Task 3.3: Implement Linux Sandbox

**Assignee:** Claude
**Dependencies:** 3.1
**Status:** Open

## Description

Implement Linux sandboxing using Landlock LSM.

## Acceptance Criteria

- [ ] Create `src/sandbox/linux.rs`
- [ ] Implement `LinuxSandbox` struct
- [ ] Implement Landlock ruleset creation
- [ ] Handle the allowlist nature of Landlock (allow everything except secrets)
- [ ] Implement fallback for kernels < 5.13 (warn and continue)
- [ ] Set environment variables before exec
- [ ] Use `nix` crate for exec

## Implementation Approach

Landlock is allowlist-based, so we need to:
1. Create a ruleset allowing all filesystem access
2. NOT add rules for the secrets directory
3. Restrict self to the ruleset

```rust
// src/sandbox/linux.rs

use landlock::{
    Access, AccessFs, PathBeneath, PathFd, Ruleset, RulesetAttr,
    RulesetCreated, RulesetStatus, ABI,
};
use crate::error::{Result, SandboxError};
use crate::sandbox::{Sandbox, SandboxConfig};
use std::convert::Infallible;

pub struct LinuxSandbox;

impl Sandbox for LinuxSandbox {
    fn exec_sandboxed(
        &self,
        config: &SandboxConfig,
        cmd: &str,
        args: &[String],
    ) -> Result<Infallible> {
        if !is_landlock_available() {
            tracing::warn!("Landlock not available (kernel 5.13+ required)");
            tracing::warn!("Secrets directory is NOT protected");
            return exec_without_sandbox(config, cmd, args);
        }

        // Create ruleset
        let abi = ABI::V3;
        let mut ruleset = Ruleset::default()
            .handle_access(AccessFs::from_all(abi))?
            .create()?;

        // Add rules allowing access to everything EXCEPT denied paths
        // This requires careful handling of the allowlist model
        add_allowed_paths(&mut ruleset, &config.deny_read)?;

        // Restrict self
        ruleset.restrict_self()?;

        // Set environment
        for (k, v) in &config.env {
            std::env::set_var(k, v);
        }

        // Exec into command
        exec_command(cmd, args)
    }
}

fn is_landlock_available() -> bool {
    // Check kernel version or try to create a minimal ruleset
    landlock::ABI::V1.try_compat().is_ok()
}

fn exec_command(cmd: &str, args: &[String]) -> Result<Infallible> {
    use nix::unistd::execvp;
    use std::ffi::CString;

    let cmd_cstr = CString::new(cmd)?;
    let args_cstr: Vec<CString> = std::iter::once(cmd.to_string())
        .chain(args.iter().cloned())
        .map(|s| CString::new(s))
        .collect::<std::result::Result<Vec<_>, _>>()?;

    execvp(&cmd_cstr, &args_cstr)
        .map_err(|e| SandboxError::Exec(e.to_string()))?;

    unreachable!()
}
```

## Landlock Allowlist Strategy

Since Landlock is allowlist-based, we need to allow access to common paths while excluding secrets:

1. Allow `/` recursively for read
2. Allow common writable locations (`/tmp`, `$HOME`, etc.)
3. Do NOT add the secrets directory to any rule

See Landlock crate documentation for examples.

## Notes

- Landlock ABI versions: V1 (5.13), V2 (5.19), V3 (6.2)
- Fall back gracefully on older kernels
- Consider using `prctl` for additional hardening
