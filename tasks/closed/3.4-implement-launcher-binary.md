# Task 3.4: Implement Launcher Binary

**Assignee:** Claude
**Dependencies:** 3.1, 2.1
**Status:** Open

## Description

Create the `clawproxy-run` binary that launches commands in a sandbox.

## Acceptance Criteria

- [ ] Create `src/bin/clawproxy_run.rs`
- [ ] Parse CLI arguments with clap
- [ ] Load config to find secrets directory
- [ ] Build `SandboxConfig`
- [ ] Call `sandbox.exec_sandboxed()`
- [ ] Support `--no-sandbox` flag for debugging
- [ ] Print helpful info about sandbox being applied

## Implementation

```rust
// src/bin/clawproxy_run.rs

use clap::Parser;
use clawproxy::{config::Config, sandbox};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "clawproxy-run")]
#[command(about = "Run a command in a sandbox without access to API secrets")]
#[command(version)]
struct Cli {
    /// Command to run
    #[arg(required = true)]
    command: String,

    /// Arguments to pass to command
    #[arg(trailing_var_arg = true)]
    args: Vec<String>,

    /// Config file path
    #[arg(short, long)]
    config: Option<PathBuf>,

    /// Proxy URL
    #[arg(long, default_value = "http://127.0.0.1:8080")]
    proxy: String,

    /// Skip sandbox (dangerous, for debugging)
    #[arg(long, hide = true)]
    no_sandbox: bool,
}

fn main() -> anyhow::Result<()> {
    clawproxy::init_tracing();

    let cli = Cli::parse();
    let config = Config::load(cli.config.as_deref())?;
    let secrets_dir = config.secrets_dir();

    tracing::info!(
        sandbox = if cli.no_sandbox { "disabled" } else {
            if cfg!(target_os = "macos") { "macOS (sandbox-exec)" }
            else { "Linux (Landlock)" }
        },
        secrets_dir = %secrets_dir.display(),
        proxy = %cli.proxy,
        command = %cli.command,
        "Launching sandboxed process"
    );

    if cli.no_sandbox {
        tracing::warn!("Running without sandbox protection!");
        // Just exec without sandbox
        return exec_without_sandbox(&cli.command, &cli.args);
    }

    let sandbox_config = sandbox::SandboxConfig::for_secrets(
        secrets_dir,
        &cli.proxy,
    );

    let sandbox = sandbox::create_sandbox()?;
    sandbox.exec_sandboxed(&sandbox_config, &cli.command, &cli.args)?;

    unreachable!()
}

fn exec_without_sandbox(cmd: &str, args: &[String]) -> anyhow::Result<()> {
    use std::os::unix::process::CommandExt;
    let err = std::process::Command::new(cmd)
        .args(args)
        .exec();
    Err(err.into())
}
```

## Usage Examples

```bash
# Run a command sandboxed
clawproxy-run ./my-agent --task "do something"

# Run with custom proxy URL
clawproxy-run --proxy http://localhost:9000 python agent.py

# Debug mode (no sandbox)
clawproxy-run --no-sandbox cat ~/.config/clawproxy/secrets/openai
```

## Notes

- The binary should not return on successful exec
- Print sandbox type being used for transparency
- Consider adding `--verbose` flag for debugging
