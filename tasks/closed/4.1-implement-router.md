# Task 4.1: Implement Router

**Assignee:** Claude
**Dependencies:** 2.1
**Status:** Open

## Description

Implement URL routing to match incoming requests to service configurations.

## Acceptance Criteria

- [ ] Create `src/proxy/router.rs`
- [ ] Implement `match_service()` to find service by URL prefix
- [ ] Implement `rewrite_path()` to strip prefix from path
- [ ] Handle query strings correctly
- [ ] Return service config and rewritten path

## Implementation

```rust
// src/proxy/router.rs

use crate::config::ServiceConfig;
use std::collections::HashMap;

/// Match a request path to a service configuration
pub fn match_service<'a>(
    path: &str,
    services: &'a HashMap<String, ServiceConfig>,
) -> Option<(&'a str, &'a ServiceConfig)> {
    for (name, config) in services {
        if path.starts_with(&config.prefix) {
            return Some((name.as_str(), config));
        }
    }
    None
}

/// Rewrite path by removing service prefix
pub fn rewrite_path(path: &str, prefix: &str) -> String {
    path.strip_prefix(prefix)
        .unwrap_or(path)
        .to_string()
}

/// Build the upstream URL from service config and request path
pub fn build_upstream_url(
    service: &ServiceConfig,
    path: &str,
    query: Option<&str>,
) -> String {
    let rewritten = rewrite_path(path, &service.prefix);
    match query {
        Some(q) => format!("{}{}?{}", service.upstream, rewritten, q),
        None => format!("{}{}", service.upstream, rewritten),
    }
}
```

## Examples

```
Input:  /openai/v1/chat/completions?stream=true
Match:  openai service (prefix: /openai)
Output: https://api.openai.com/v1/chat/completions?stream=true

Input:  /anthropic/v1/messages
Match:  anthropic service (prefix: /anthropic)
Output: https://api.anthropic.com/v1/messages
```

## Notes

- Consider prefix ordering if prefixes could overlap
- Query string should be preserved exactly
