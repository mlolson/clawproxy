# Task 4.3: Implement HTTP Server

**Assignee:** Claude
**Dependencies:** 4.1
**Status:** Open

## Description

Set up the Axum HTTP server to receive proxy requests.

## Acceptance Criteria

- [ ] Create `src/proxy/server.rs`
- [ ] Implement `ProxyServer` struct
- [ ] Set up Axum router with catch-all handler
- [ ] Add tower-http tracing middleware
- [ ] Implement graceful shutdown on SIGTERM/SIGINT

## Implementation

```rust
// src/proxy/server.rs

use axum::{
    body::Body,
    extract::State,
    http::{Request, StatusCode},
    response::Response,
    Router,
};
use std::sync::Arc;
use tokio::signal;
use tower_http::trace::TraceLayer;

use crate::config::Config;
use crate::error::Result;

pub struct ProxyServer {
    config: Config,
    secrets: HashMap<String, String>,
}

#[derive(Clone)]
struct AppState {
    config: Arc<Config>,
    secrets: Arc<HashMap<String, String>>,
}

impl ProxyServer {
    pub fn new(config: Config, secrets: HashMap<String, String>) -> Self {
        Self { config, secrets }
    }

    pub async fn run(self) -> Result<()> {
        let state = AppState {
            config: Arc::new(self.config.clone()),
            secrets: Arc::new(self.secrets),
        };

        let app = Router::new()
            .fallback(proxy_handler)
            .layer(TraceLayer::new_for_http())
            .with_state(state);

        let addr = format!("{}:{}", self.config.listen.host, self.config.listen.port);
        let listener = tokio::net::TcpListener::bind(&addr).await?;

        tracing::info!(addr = %addr, "Proxy server listening");

        axum::serve(listener, app)
            .with_graceful_shutdown(shutdown_signal())
            .await?;

        Ok(())
    }
}

async fn proxy_handler(
    State(state): State<AppState>,
    request: Request<Body>,
) -> Result<Response<Body>, StatusCode> {
    // TODO: Implement in task 4.4
    todo!()
}

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c().await.expect("Failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("Failed to install SIGTERM handler")
            .recv()
            .await;
    };

    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }

    tracing::info!("Shutdown signal received");
}
```

## Routes

All routes go to the catch-all handler which:
1. Matches path to service
2. Rewrites URL
3. Substitutes tokens
4. Forwards request

## Notes

- Use `Arc` for shared state to avoid cloning config/secrets
- TraceLayer provides request/response logging
- Consider rate limiting middleware (future)
