# Task 4.5: Implement Response Streaming

**Assignee:** Claude
**Dependencies:** 4.4
**Status:** Open

## Description

Implement streaming responses from upstream, crucial for SSE (Server-Sent Events) used by AI APIs.

## Acceptance Criteria

- [ ] Stream response body instead of buffering
- [ ] Preserve SSE format for streaming APIs
- [ ] Copy response headers correctly
- [ ] Handle both streaming and non-streaming responses
- [ ] Preserve status codes

## Implementation

```rust
use axum::{
    body::Body,
    http::{Response, StatusCode},
};
use futures::StreamExt;

async fn convert_response(
    upstream_response: reqwest::Response,
) -> Result<Response<Body>, ProxyError> {
    let status = upstream_response.status();
    let headers = upstream_response.headers().clone();

    // Check if this is a streaming response
    let is_streaming = headers
        .get("content-type")
        .map(|v| v.to_str().unwrap_or("").contains("text/event-stream"))
        .unwrap_or(false);

    let body = if is_streaming {
        // Stream the response
        let stream = upstream_response.bytes_stream();
        Body::from_stream(stream)
    } else {
        // Buffer small responses
        let bytes = upstream_response.bytes().await
            .map_err(|e| ProxyError::UpstreamRequest(e.to_string()))?;
        Body::from(bytes)
    };

    let mut response = Response::builder()
        .status(StatusCode::from_u16(status.as_u16()).unwrap_or(StatusCode::OK));

    // Copy headers
    for (name, value) in headers.iter() {
        // Skip hop-by-hop headers
        if !is_hop_by_hop(name.as_str()) {
            response = response.header(name, value);
        }
    }

    response.body(body)
        .map_err(|e| ProxyError::UpstreamRequest(e.to_string()))
}

fn is_hop_by_hop(header: &str) -> bool {
    matches!(
        header.to_lowercase().as_str(),
        "connection" | "keep-alive" | "proxy-authenticate" |
        "proxy-authorization" | "te" | "trailers" |
        "transfer-encoding" | "upgrade"
    )
}
```

## SSE Format

Server-Sent Events look like:
```
data: {"choices":[{"delta":{"content":"Hello"}}]}

data: {"choices":[{"delta":{"content":" world"}}]}

data: [DONE]
```

Each chunk must be forwarded immediately, not buffered.

## Headers to Skip

Hop-by-hop headers that shouldn't be forwarded:
- Connection
- Keep-Alive
- Transfer-Encoding
- Upgrade
- Proxy-* headers

## Notes

- Use `Body::from_stream()` for streaming
- Test with `curl --no-buffer` to verify streaming works
- OpenAI and Anthropic both use SSE for streaming
