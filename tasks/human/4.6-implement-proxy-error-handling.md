# Task 4.6: Implement Proxy Error Handling

**Assignee:** Human
**Dependencies:** 4.3, 4.4, 4.5
**Status:** Open

## Why This Task is Assigned to Human

Understanding error flows end-to-end is crucial for debugging. This task helps you understand what can go wrong and how to handle it gracefully.

## Description

Implement comprehensive error handling for the proxy server.

## Acceptance Criteria

- [ ] Handle unknown service prefix (404)
- [ ] Handle missing secrets (500 with helpful message)
- [ ] Handle upstream connection failures
- [ ] Handle upstream timeouts
- [ ] Handle malformed requests
- [ ] Return appropriate HTTP status codes
- [ ] Log errors with context (but not secrets)

## Error Scenarios

| Scenario | Status Code | Response Body |
|----------|-------------|---------------|
| Unknown prefix | 404 | `{"error": "Unknown service: /foo"}` |
| Missing secret | 500 | `{"error": "Configuration error"}` |
| Upstream down | 502 | `{"error": "Upstream unavailable"}` |
| Upstream timeout | 504 | `{"error": "Upstream timeout"}` |
| Invalid request | 400 | `{"error": "Invalid request"}` |

## Implementation

```rust
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

// Custom error type that implements IntoResponse
pub struct ProxyError {
    status: StatusCode,
    message: String,
    // Internal details for logging (not sent to client)
    details: Option<String>,
}

impl IntoResponse for ProxyError {
    fn into_response(self) -> Response {
        // Log the error with details
        tracing::error!(
            status = %self.status,
            message = %self.message,
            details = ?self.details,
            "Proxy error"
        );

        // Return sanitized response to client
        let body = Json(json!({
            "error": self.message
        }));

        (self.status, body).into_response()
    }
}

impl ProxyError {
    pub fn not_found(path: &str) -> Self {
        Self {
            status: StatusCode::NOT_FOUND,
            message: format!("Unknown service prefix: {}", path),
            details: None,
        }
    }

    pub fn upstream_error(err: reqwest::Error) -> Self {
        let (status, message) = if err.is_timeout() {
            (StatusCode::GATEWAY_TIMEOUT, "Upstream timeout")
        } else if err.is_connect() {
            (StatusCode::BAD_GATEWAY, "Upstream unavailable")
        } else {
            (StatusCode::BAD_GATEWAY, "Upstream error")
        };

        Self {
            status,
            message: message.to_string(),
            details: Some(err.to_string()),
        }
    }

    pub fn config_error(msg: &str) -> Self {
        Self {
            status: StatusCode::INTERNAL_SERVER_ERROR,
            // Don't expose internal details to client
            message: "Configuration error".to_string(),
            details: Some(msg.to_string()),
        }
    }
}
```

## Handler Updates

```rust
async fn proxy_handler(
    State(state): State<AppState>,
    request: Request<Body>,
) -> Result<Response<Body>, ProxyError> {
    let path = request.uri().path();

    // Match service
    let (_, service) = router::match_service(path, &state.config.services)
        .ok_or_else(|| ProxyError::not_found(path))?;

    // Get secret
    let secret = state.secrets
        .get(&service.secret)
        .ok_or_else(|| ProxyError::config_error(
            &format!("Missing secret: {}", service.secret)
        ))?;

    // Forward request
    forward_request(&state, request, service, secret)
        .await
        .map_err(ProxyError::upstream_error)
}
```

## Testing

```bash
# Test unknown prefix
curl http://localhost:8080/unknown/path
# Expected: 404 {"error": "Unknown service prefix: /unknown/path"}

# Test with proxy not running upstream
# (configure a service pointing to localhost:9999)
curl http://localhost:8080/test/endpoint
# Expected: 502 {"error": "Upstream unavailable"}
```

## Hints

- Never expose internal errors or secrets in responses
- Log enough detail to debug, but sanitize for clients
- Consider adding request IDs for tracing
- Test timeout handling with a slow endpoint
