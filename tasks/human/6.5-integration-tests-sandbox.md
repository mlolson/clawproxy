# Task 6.5: Integration Tests â€” Sandbox

**Assignee:** Human
**Dependencies:** 3.5
**Status:** Open

## Why This Task is Assigned to Human

Sandbox tests require running on actual platforms and verifying security properties. This needs human judgment and real hardware.

## Description

Write integration tests that verify sandbox behavior on both platforms.

## Acceptance Criteria

- [ ] Test macOS sandbox blocks file access
- [ ] Test Linux Landlock blocks file access
- [ ] Test fallback warning on old kernel
- [ ] Test subprocess inherits sandbox
- [ ] Tests can run in CI

## Test Structure

```rust
// tests/sandbox_integration.rs

use assert_cmd::Command;
use predicates::prelude::*;
use tempfile::TempDir;
use std::fs;

/// Setup a test environment with secrets
fn setup_test_env() -> TempDir {
    let dir = TempDir::new().unwrap();
    let secrets_dir = dir.path().join("secrets");
    fs::create_dir_all(&secrets_dir).unwrap();
    fs::write(secrets_dir.join("test_secret"), "super-secret-value").unwrap();

    // Set restrictive permissions
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        fs::set_permissions(&secrets_dir, fs::Permissions::from_mode(0o700)).unwrap();
    }

    dir
}
```

## Test Cases

```rust
#[test]
#[cfg(target_os = "macos")]
fn test_macos_sandbox_blocks_read() {
    let env = setup_test_env();
    let secret_path = env.path().join("secrets/test_secret");

    // Verify secret is readable normally
    let content = fs::read_to_string(&secret_path).unwrap();
    assert_eq!(content, "super-secret-value");

    // Verify sandbox blocks read
    let mut cmd = Command::cargo_bin("clawproxy-run").unwrap();
    cmd.env("CLAWPROXY_SECRETS_DIR", env.path().join("secrets"))
        .arg("cat")
        .arg(&secret_path)
        .assert()
        .failure()
        .stderr(predicate::str::contains("Operation not permitted")
            .or(predicate::str::contains("Permission denied")));
}

#[test]
#[cfg(target_os = "linux")]
fn test_linux_landlock_blocks_read() {
    let env = setup_test_env();
    let secret_path = env.path().join("secrets/test_secret");

    let mut cmd = Command::cargo_bin("clawproxy-run").unwrap();
    cmd.env("CLAWPROXY_SECRETS_DIR", env.path().join("secrets"))
        .arg("cat")
        .arg(&secret_path)
        .assert()
        .failure();
}

#[test]
fn test_sandbox_allows_other_files() {
    let env = setup_test_env();

    // Create a non-secret file
    let other_file = env.path().join("allowed.txt");
    fs::write(&other_file, "allowed content").unwrap();

    // Should be able to read non-secret files
    let mut cmd = Command::cargo_bin("clawproxy-run").unwrap();
    cmd.env("CLAWPROXY_SECRETS_DIR", env.path().join("secrets"))
        .arg("cat")
        .arg(&other_file)
        .assert()
        .success()
        .stdout(predicate::str::contains("allowed content"));
}

#[test]
fn test_subprocess_inherits_sandbox() {
    let env = setup_test_env();
    let secret_path = env.path().join("secrets/test_secret");

    // Create a script that tries to read the secret
    let script = env.path().join("sneaky.sh");
    fs::write(&script, format!("#!/bin/bash\ncat {}", secret_path.display())).unwrap();

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        fs::set_permissions(&script, fs::Permissions::from_mode(0o755)).unwrap();
    }

    // Subprocess should also be blocked
    let mut cmd = Command::cargo_bin("clawproxy-run").unwrap();
    cmd.env("CLAWPROXY_SECRETS_DIR", env.path().join("secrets"))
        .arg(&script)
        .assert()
        .failure();
}

#[test]
fn test_env_vars_set() {
    let mut cmd = Command::cargo_bin("clawproxy-run").unwrap();
    cmd.arg("env")
        .assert()
        .success()
        .stdout(predicate::str::contains("HTTP_PROXY="))
        .stdout(predicate::str::contains("HTTPS_PROXY="));
}

#[test]
#[cfg(target_os = "linux")]
fn test_landlock_fallback_warning() {
    // This test is tricky - need to mock kernel version
    // or run on an old kernel
    // For now, just document expected behavior
}
```

## CI Configuration

```yaml
# .github/workflows/test.yml
jobs:
  sandbox-tests:
    strategy:
      matrix:
        os: [macos-13, macos-14, ubuntu-22.04, ubuntu-24.04]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - name: Run sandbox tests
        run: cargo test --test sandbox_integration
```

## Notes

- Some tests may need to be skipped in certain CI environments
- Use `#[ignore]` for tests that need special setup
- Document any platform-specific requirements
- Consider Docker for testing old Linux kernels
